그래프 응용 1부 그래프 탐색 DFS와 BFS
===============

Contents
-------------------

1. 시작하며...
2. 깊이 우선 탐색 DFS
    * DFS 이해
    * DFS 구현 - 스택
    * DFS 구현 - 재귀
3. 너비 우선 탐색 BFS
    * BFS 이해
    * BFS 구현
4. 마치며...

## 시작하며...

구르미의 "Computer Science 정복하기 - 자료구조"의 스물 네 번째 장입니다. 이 장의 대략적인 내용은 다음과 같습니다. 

* DFS의 이해와 구현
* BFS의 이해와 구현

이 장의 소스코드는 다음을 참고해주세요.

    url: https://github.com/gurumee92/datastructure 
    branch: ch24
    code directory: src/ch24

자 시작합시다!


## 깊이 우선 탐색 DFS

먼저 그래프의 모든 정점을 탐색하는 방법 중 하나로 **깊이 우선 탐색**, 영어로는 "Depth First Search", 줄여서 DFS에 대해 알아보겠습니다.


### DFS 이해


### DFS 구현 - 스택

src/ch24/dfs/main.c
```c
#include "Stack.h"
void push(Stack * pStack, int data) {
    int * p = (int *) malloc(sizeof(int));
    *p = data;
    SPush(pStack, p);
}

int pop(Stack * pStack) {
    int data = *((int *) SPop(pStack));
    return data;
}

int isAllVisit(int * visitInfo) {
    for (int i=0; i<NUMBER_OF_VERTEX; i++) {
        if (visitInfo[i] != 1) {
            return 0;
        }
    }

    return 1;
}

void DFSWithStack(int (*graph)[NUMBER_OF_VERTEX], int * visitInfo, int start) {
    Stack stack;
    SInit(&stack);

    push(&stack, start);
    
    while (!SIsEmpty(&stack) && !isAllVisit(visitInfo)) {
        int visit = pop(&stack);

        if (visitInfo[visit]) {
            continue;
        }

        visitInfo[visit] = 1;
        printf("%d ", visit);
        
        for (int to=NUMBER_OF_VERTEX-1; to>=0; to--) {
            if (graph[visit][to] && !visitInfo[to]) {
                push(&stack, to);
            }
        }
    }

    printf("\n");
    SDestroy(&stack);
}
```


### DFS 구현 - 재귀

src/ch24/dfs/main.c
```c
void DFSWithRecursion(int (*graph)[NUMBER_OF_VERTEX], int * visitInfo, int visit) {
    if (visitInfo[visit] || isAllVisit(visitInfo)) {
        printf("\n");
        return;
    }

    visitInfo[visit] = 1;
    printf("%d " , visit);

    for (int to=0; to<NUMBER_OF_VERTEX; to++) {
        if (graph[visit][to] && !visitInfo[to]) {
            DFSWithRecursion(graph, visitInfo, to);
        }
    }
}
```


## 너비 우선 탐색 BFS

이제 그래프의 모든 정점을 탐색하는 다른 방법으로 **너비 우선 탐색**, 영어로는 "Breadth First Search", 줄여서 BFS에 대해 알아보겠습니다.


### BFS 이해


### BFS 구현


src/ch24/bfs/main.c
```c
#include "Queue.h"

void enqueue(Queue * pQueue, int data) {
    int * p = (int *) malloc(sizeof(int));
    *p = data;
    Enqueue(pQueue, p);
}

int dequeue(Queue * pQueue) {
    int data = *((int *) Dequeue(pQueue));
    return data;
}

int isAllVisit(int * visitInfo) {
    for (int i=0; i<NUMBER_OF_VERTEX; i++) {
        if (visitInfo[i] != 1) {
            return 0;
        }
    }

    return 1;
}

void BFS(int (*graph)[NUMBER_OF_VERTEX], int * visitInfo, int start) {
    Queue queue;
    QInit(&queue);

    enqueue(&queue, start);
    
    while (!QIsEmpty(&queue) && !isAllVisit(visitInfo)) {
        int visit = dequeue(&queue);

        if (visitInfo[visit]) {
            continue;
        }

        visitInfo[visit] = 1;
        printf("%d ", visit);
        
        for (int to=0; to < NUMBER_OF_VERTEX; to++) {
            if (graph[visit][to] && !visitInfo[to]) {
                enqueue(&queue, to);
            }
        }
    }

    printf("\n");
    QDestroy(&queue);
}
```


## 마치며...

이번 시간에는 그래프의 모든 정정을 탐색하는 2가지 방법, 깊이 우선 탐색(DFS)와, 너비 우선 탐색(BFS)에 대해 공부하였습니다. **깊이 우선 탐색은 보통, 완전 탐색 알고리즘에 자주 쓰이며, 너비 우선 탐색은 최단 거리 알고리즘에 쓰입니다.** 이들은, 매우 유용하고 중요합니다. 탐색 방버의 응용에 대해서는 추후 알고리즘 파트에서 다루도록 하겠습니다. 지금은 "DFS, BFS는 이런 방식으로 동작하는구나" 정도로 알고 넘어가시면 될 것 같습니다.

다음 시간에는 자료구조 파트의 마지막 장이자, 그래프의 다른 응용인 최소 신장 트리와, 그것을 만들게 하는 크루스칼 알고리즘에 대해서 공부하도록 하겠습니다.

